{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setIsRefreshing = exports.getIsRefreshing = exports.authTokenInterceptor = exports.applyAuthTokenInterceptor = exports.refreshTokenIfNeeded = exports.getAccessToken = exports.getRefreshToken = exports.clearAuthTokens = exports.setAccessToken = exports.setAuthTokens = exports.isLoggedIn = exports.STORAGE_KEY = void 0;\n\nvar jwt_decode_1 = __importDefault(require(\"jwt-decode\"));\n\nvar axios_1 = __importDefault(require(\"axios\"));\n\nvar async_storage_1 = __importDefault(require(\"@react-native-async-storage/async-storage\"));\n\nvar EXPIRE_FUDGE = 10;\nexports.STORAGE_KEY = \"auth-tokens-\" + process.env.NODE_ENV;\n\nvar isLoggedIn = function isLoggedIn() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var token;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, (0, exports.getRefreshToken)()];\n\n        case 1:\n          token = _a.sent();\n          return [2, !!token];\n      }\n    });\n  });\n};\n\nexports.isLoggedIn = isLoggedIn;\n\nvar setAuthTokens = function setAuthTokens(tokens) {\n  return async_storage_1.default.setItem(exports.STORAGE_KEY, JSON.stringify(tokens));\n};\n\nexports.setAuthTokens = setAuthTokens;\n\nvar setAccessToken = function setAccessToken(token) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, getAuthTokens()];\n\n        case 1:\n          tokens = _a.sent();\n\n          if (!tokens) {\n            throw new Error('Unable to update access token since there are not tokens currently stored');\n          }\n\n          tokens.accessToken = token;\n          return [2, (0, exports.setAuthTokens)(tokens)];\n      }\n    });\n  });\n};\n\nexports.setAccessToken = setAccessToken;\n\nvar clearAuthTokens = function clearAuthTokens() {\n  return async_storage_1.default.removeItem(exports.STORAGE_KEY);\n};\n\nexports.clearAuthTokens = clearAuthTokens;\n\nvar getRefreshToken = function getRefreshToken() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, getAuthTokens()];\n\n        case 1:\n          tokens = _a.sent();\n          return [2, tokens ? tokens.refreshToken : undefined];\n      }\n    });\n  });\n};\n\nexports.getRefreshToken = getRefreshToken;\n\nvar getAccessToken = function getAccessToken() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, getAuthTokens()];\n\n        case 1:\n          tokens = _a.sent();\n          return [2, tokens ? tokens.accessToken : undefined];\n      }\n    });\n  });\n};\n\nexports.getAccessToken = getAccessToken;\n\nvar refreshTokenIfNeeded = function refreshTokenIfNeeded(requestRefresh) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var accessToken;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, (0, exports.getAccessToken)()];\n\n        case 1:\n          accessToken = _a.sent();\n          if (!(!accessToken || isTokenExpired(accessToken))) return [3, 3];\n          return [4, refreshToken(requestRefresh)];\n\n        case 2:\n          accessToken = _a.sent();\n          _a.label = 3;\n\n        case 3:\n          return [2, accessToken];\n      }\n    });\n  });\n};\n\nexports.refreshTokenIfNeeded = refreshTokenIfNeeded;\n\nvar applyAuthTokenInterceptor = function applyAuthTokenInterceptor(axios, config) {\n  if (!axios.interceptors) throw new Error(\"invalid axios instance: \" + axios);\n  axios.interceptors.request.use((0, exports.authTokenInterceptor)(config));\n};\n\nexports.applyAuthTokenInterceptor = applyAuthTokenInterceptor;\n\nvar getAuthTokens = function getAuthTokens() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var rawTokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, async_storage_1.default.getItem(exports.STORAGE_KEY)];\n\n        case 1:\n          rawTokens = _a.sent();\n          if (!rawTokens) return [2];\n\n          try {\n            return [2, JSON.parse(rawTokens)];\n          } catch (error) {\n            throw new Error(\"Failed to parse auth tokens: \" + rawTokens);\n          }\n\n          return [2];\n      }\n    });\n  });\n};\n\nvar isTokenExpired = function isTokenExpired(token) {\n  if (!token) return true;\n  var expiresIn = getExpiresIn(token);\n  return !expiresIn || expiresIn <= EXPIRE_FUDGE;\n};\n\nvar getTimestampFromToken = function getTimestampFromToken(token) {\n  var decoded = (0, jwt_decode_1.default)(token);\n  return decoded.exp;\n};\n\nvar getExpiresIn = function getExpiresIn(token) {\n  var expiration = getTimestampFromToken(token);\n  if (!expiration) return -1;\n  return expiration - Date.now() / 1000;\n};\n\nvar refreshToken = function refreshToken(requestRefresh) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var refreshToken, newTokens, error_1, status_1;\n\n    var _a;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4, (0, exports.getRefreshToken)()];\n\n        case 1:\n          refreshToken = _b.sent();\n          if (!refreshToken) throw new Error('No refresh token available');\n          _b.label = 2;\n\n        case 2:\n          _b.trys.push([2, 8,, 11]);\n\n          return [4, requestRefresh(refreshToken)];\n\n        case 3:\n          newTokens = _b.sent();\n          if (!(typeof newTokens === 'object' && (newTokens === null || newTokens === void 0 ? void 0 : newTokens.accessToken))) return [3, 5];\n          return [4, (0, exports.setAuthTokens)(newTokens)];\n\n        case 4:\n          _b.sent();\n\n          return [2, newTokens.accessToken];\n\n        case 5:\n          if (!(typeof newTokens === 'string')) return [3, 7];\n          return [4, (0, exports.setAccessToken)(newTokens)];\n\n        case 6:\n          _b.sent();\n\n          return [2, newTokens];\n\n        case 7:\n          return [3, 11];\n\n        case 8:\n          error_1 = _b.sent();\n          if (!axios_1.default.isAxiosError(error_1)) throw error_1;\n          status_1 = (_a = error_1.response) === null || _a === void 0 ? void 0 : _a.status;\n          if (!(status_1 === 401 || status_1 === 422)) return [3, 10];\n          return [4, async_storage_1.default.removeItem(exports.STORAGE_KEY)];\n\n        case 9:\n          _b.sent();\n\n          error_1.message = \"Got \" + status_1 + \" on token refresh; clearing both auth tokens\";\n          _b.label = 10;\n\n        case 10:\n          throw error_1;\n\n        case 11:\n          throw new Error('requestRefresh must either return a string or an object with an accessToken');\n      }\n    });\n  });\n};\n\nvar authTokenInterceptor = function authTokenInterceptor(_a) {\n  var _b = _a.header,\n      header = _b === void 0 ? 'Authorization' : _b,\n      _c = _a.headerPrefix,\n      headerPrefix = _c === void 0 ? 'Bearer ' : _c,\n      requestRefresh = _a.requestRefresh;\n  return function (requestConfig) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var refreshToken, authenticateRequest, accessToken, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4, (0, exports.getRefreshToken)()];\n\n          case 1:\n            refreshToken = _a.sent();\n            if (!refreshToken) return [2, requestConfig];\n\n            authenticateRequest = function authenticateRequest(token) {\n              if (token) requestConfig.headers[header] = \"\" + headerPrefix + token;\n              return requestConfig;\n            };\n\n            if (isRefreshing) {\n              return [2, new Promise(function (resolve, reject) {\n                queue.push({\n                  resolve: resolve,\n                  reject: reject\n                });\n              }).then(authenticateRequest)];\n            }\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4, 5, 6]);\n\n            isRefreshing = true;\n            return [4, (0, exports.refreshTokenIfNeeded)(requestRefresh)];\n\n          case 3:\n            accessToken = _a.sent();\n            return [3, 6];\n\n          case 4:\n            error_2 = _a.sent();\n            declineQueue(error_2);\n\n            if (error_2 instanceof Error) {\n              error_2.message = \"Unable to refresh access token for request due to token refresh error: \" + error_2.message;\n            }\n\n            throw error_2;\n\n          case 5:\n            isRefreshing = false;\n            return [7];\n\n          case 6:\n            resolveQueue(accessToken);\n            return [2, authenticateRequest(accessToken)];\n        }\n      });\n    });\n  };\n};\n\nexports.authTokenInterceptor = authTokenInterceptor;\nvar isRefreshing = false;\nvar queue = [];\n\nfunction getIsRefreshing() {\n  return isRefreshing;\n}\n\nexports.getIsRefreshing = getIsRefreshing;\n\nfunction setIsRefreshing(newRefreshingState) {\n  isRefreshing = newRefreshingState;\n}\n\nexports.setIsRefreshing = setIsRefreshing;\n\nvar resolveQueue = function resolveQueue(token) {\n  queue.forEach(function (p) {\n    p.resolve(token);\n  });\n  queue = [];\n};\n\nvar declineQueue = function declineQueue(error) {\n  queue.forEach(function (p) {\n    p.reject(error);\n  });\n  queue = [];\n};","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setIsRefreshing = exports.getIsRefreshing = exports.authTokenInterceptor = exports.applyAuthTokenInterceptor = exports.refreshTokenIfNeeded = exports.getAccessToken = exports.getRefreshToken = exports.clearAuthTokens = exports.setAccessToken = exports.setAuthTokens = exports.isLoggedIn = exports.STORAGE_KEY = void 0;\nvar jwt_decode_1 = __importDefault(require(\"jwt-decode\"));\nvar axios_1 = __importDefault(require(\"axios\"));\nvar async_storage_1 = __importDefault(require(\"@react-native-async-storage/async-storage\"));\n// a little time before expiration to try refresh (seconds)\nvar EXPIRE_FUDGE = 10;\nexports.STORAGE_KEY = \"auth-tokens-\" + process.env.NODE_ENV;\n// EXPORTS\n/**\n * Checks if refresh tokens are stored\n * @async\n * @returns {Promise<boolean>} Whether the user is logged in or not\n */\nvar isLoggedIn = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var token;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, (0, exports.getRefreshToken)()];\n            case 1:\n                token = _a.sent();\n                return [2 /*return*/, !!token];\n        }\n    });\n}); };\nexports.isLoggedIn = isLoggedIn;\n/**\n * Sets the access and refresh tokens\n * @async\n * @param {AuthTokens} tokens - Access and Refresh tokens\n * @returns {Promise}\n */\nvar setAuthTokens = function (tokens) {\n    return async_storage_1.default.setItem(exports.STORAGE_KEY, JSON.stringify(tokens));\n};\nexports.setAuthTokens = setAuthTokens;\n/**\n * Sets the access token\n * @async\n * @param {Promise} token - Access token\n */\nvar setAccessToken = function (token) { return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, getAuthTokens()];\n            case 1:\n                tokens = _a.sent();\n                if (!tokens) {\n                    throw new Error('Unable to update access token since there are not tokens currently stored');\n                }\n                tokens.accessToken = token;\n                return [2 /*return*/, (0, exports.setAuthTokens)(tokens)];\n        }\n    });\n}); };\nexports.setAccessToken = setAccessToken;\n/**\n * Clears both tokens\n * @async\n * @returns {Promise}\n */\nvar clearAuthTokens = function () { return async_storage_1.default.removeItem(exports.STORAGE_KEY); };\nexports.clearAuthTokens = clearAuthTokens;\n/**\n * Returns the stored refresh token\n * @async\n * @returns {Promise<string>} Refresh token\n */\nvar getRefreshToken = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, getAuthTokens()];\n            case 1:\n                tokens = _a.sent();\n                return [2 /*return*/, tokens ? tokens.refreshToken : undefined];\n        }\n    });\n}); };\nexports.getRefreshToken = getRefreshToken;\n/**\n * Returns the stored access token\n * @async\n * @returns {Promise<string>} Access token\n */\nvar getAccessToken = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, getAuthTokens()];\n            case 1:\n                tokens = _a.sent();\n                return [2 /*return*/, tokens ? tokens.accessToken : undefined];\n        }\n    });\n}); };\nexports.getAccessToken = getAccessToken;\n/**\n * @callback requestRefresh\n * @param {string} refreshToken - Token that is sent to the backend\n * @returns {Promise} Promise that resolves an access token\n */\n/**\n * Gets the current access token, exchanges it with a new one if it's expired and then returns the token.\n * @async\n * @param {requestRefresh} requestRefresh - Function that is used to get a new access token\n * @returns {Promise<string>} Access token\n */\nvar refreshTokenIfNeeded = function (requestRefresh) { return __awaiter(void 0, void 0, void 0, function () {\n    var accessToken;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, (0, exports.getAccessToken)()\n                // check if access token is expired\n            ];\n            case 1:\n                accessToken = _a.sent();\n                if (!(!accessToken || isTokenExpired(accessToken))) return [3 /*break*/, 3];\n                return [4 /*yield*/, refreshToken(requestRefresh)];\n            case 2:\n                // do refresh\n                accessToken = _a.sent();\n                _a.label = 3;\n            case 3: return [2 /*return*/, accessToken];\n        }\n    });\n}); };\nexports.refreshTokenIfNeeded = refreshTokenIfNeeded;\n/**\n *\n * @param {axios} axios - Axios instance to apply the interceptor to\n * @param {AuthTokenInterceptorConfig} config - Configuration for the interceptor\n */\nvar applyAuthTokenInterceptor = function (axios, config) {\n    if (!axios.interceptors)\n        throw new Error(\"invalid axios instance: \" + axios);\n    axios.interceptors.request.use((0, exports.authTokenInterceptor)(config));\n};\nexports.applyAuthTokenInterceptor = applyAuthTokenInterceptor;\n// PRIVATE\n/**\n *  Returns the refresh and access tokens\n * @async\n * @returns {Promise<AuthTokens>} Object containing refresh and access tokens\n */\nvar getAuthTokens = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var rawTokens;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, async_storage_1.default.getItem(exports.STORAGE_KEY)];\n            case 1:\n                rawTokens = _a.sent();\n                if (!rawTokens)\n                    return [2 /*return*/];\n                try {\n                    // parse stored tokens JSON\n                    return [2 /*return*/, JSON.parse(rawTokens)];\n                }\n                catch (error) {\n                    throw new Error(\"Failed to parse auth tokens: \" + rawTokens);\n                }\n                return [2 /*return*/];\n        }\n    });\n}); };\n/**\n * Checks if the token is undefined, has expired or is about to expire\n *\n * @param {string} token - Access token\n * @returns {boolean} Whether or not the token is undefined, has expired or is about to expire\n */\nvar isTokenExpired = function (token) {\n    if (!token)\n        return true;\n    var expiresIn = getExpiresIn(token);\n    return !expiresIn || expiresIn <= EXPIRE_FUDGE;\n};\n/**\n * Gets the unix timestamp from the JWT access token\n *\n * @param {string} token - Access token\n * @returns {string} Unix timestamp\n */\nvar getTimestampFromToken = function (token) {\n    var decoded = (0, jwt_decode_1.default)(token);\n    return decoded.exp;\n};\n/**\n * Returns the number of seconds before the access token expires or -1 if it already has\n *\n * @param {string} token - Access token\n * @returns {number} Number of seconds before the access token expires\n */\nvar getExpiresIn = function (token) {\n    var expiration = getTimestampFromToken(token);\n    if (!expiration)\n        return -1;\n    return expiration - Date.now() / 1000;\n};\n/**\n * Refreshes the access token using the provided function\n * @async\n * @param {requestRefresh} requestRefresh - Function that is used to get a new access token\n * @returns {Promise<string>} - Fresh access token\n */\nvar refreshToken = function (requestRefresh) { return __awaiter(void 0, void 0, void 0, function () {\n    var refreshToken, newTokens, error_1, status_1;\n    var _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0: return [4 /*yield*/, (0, exports.getRefreshToken)()];\n            case 1:\n                refreshToken = _b.sent();\n                if (!refreshToken)\n                    throw new Error('No refresh token available');\n                _b.label = 2;\n            case 2:\n                _b.trys.push([2, 8, , 11]);\n                return [4 /*yield*/, requestRefresh(refreshToken)];\n            case 3:\n                newTokens = _b.sent();\n                if (!(typeof newTokens === 'object' && (newTokens === null || newTokens === void 0 ? void 0 : newTokens.accessToken))) return [3 /*break*/, 5];\n                return [4 /*yield*/, (0, exports.setAuthTokens)(newTokens)];\n            case 4:\n                _b.sent();\n                return [2 /*return*/, newTokens.accessToken];\n            case 5:\n                if (!(typeof newTokens === 'string')) return [3 /*break*/, 7];\n                return [4 /*yield*/, (0, exports.setAccessToken)(newTokens)];\n            case 6:\n                _b.sent();\n                return [2 /*return*/, newTokens];\n            case 7: return [3 /*break*/, 11];\n            case 8:\n                error_1 = _b.sent();\n                if (!axios_1.default.isAxiosError(error_1))\n                    throw error_1;\n                status_1 = (_a = error_1.response) === null || _a === void 0 ? void 0 : _a.status;\n                if (!(status_1 === 401 || status_1 === 422)) return [3 /*break*/, 10];\n                // The refresh token is invalid so remove the stored tokens\n                return [4 /*yield*/, async_storage_1.default.removeItem(exports.STORAGE_KEY)];\n            case 9:\n                // The refresh token is invalid so remove the stored tokens\n                _b.sent();\n                error_1.message = \"Got \" + status_1 + \" on token refresh; clearing both auth tokens\";\n                _b.label = 10;\n            case 10: throw error_1;\n            case 11: throw new Error('requestRefresh must either return a string or an object with an accessToken');\n        }\n    });\n}); };\n/**\n * Function that returns an Axios Interceptor that:\n * - Applies that right auth header to requests\n * - Refreshes the access token when needed\n * - Puts subsequent requests in a queue and executes them in order after the access token has been refreshed.\n *\n * @param {AuthTokenInterceptorConfig} config - Configuration for the interceptor\n * @returns {Promise<AxiosRequestConfig} Promise that resolves in the supplied requestConfig\n */\nvar authTokenInterceptor = function (_a) {\n    var _b = _a.header, header = _b === void 0 ? 'Authorization' : _b, _c = _a.headerPrefix, headerPrefix = _c === void 0 ? 'Bearer ' : _c, requestRefresh = _a.requestRefresh;\n    return function (requestConfig) { return __awaiter(void 0, void 0, void 0, function () {\n        var refreshToken, authenticateRequest, accessToken, error_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, (0, exports.getRefreshToken)()];\n                case 1:\n                    refreshToken = _a.sent();\n                    if (!refreshToken)\n                        return [2 /*return*/, requestConfig];\n                    authenticateRequest = function (token) {\n                        if (token)\n                            requestConfig.headers[header] = \"\" + headerPrefix + token;\n                        return requestConfig;\n                    };\n                    // Queue the request if another refresh request is currently happening\n                    if (isRefreshing) {\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                queue.push({ resolve: resolve, reject: reject });\n                            }).then(authenticateRequest)];\n                    }\n                    _a.label = 2;\n                case 2:\n                    _a.trys.push([2, 4, 5, 6]);\n                    isRefreshing = true;\n                    return [4 /*yield*/, (0, exports.refreshTokenIfNeeded)(requestRefresh)];\n                case 3:\n                    accessToken = _a.sent();\n                    return [3 /*break*/, 6];\n                case 4:\n                    error_2 = _a.sent();\n                    declineQueue(error_2);\n                    if (error_2 instanceof Error) {\n                        error_2.message = \"Unable to refresh access token for request due to token refresh error: \" + error_2.message;\n                    }\n                    throw error_2;\n                case 5:\n                    isRefreshing = false;\n                    return [7 /*endfinally*/];\n                case 6:\n                    resolveQueue(accessToken);\n                    // add token to headers\n                    return [2 /*return*/, authenticateRequest(accessToken)];\n            }\n        });\n    }); };\n};\nexports.authTokenInterceptor = authTokenInterceptor;\nvar isRefreshing = false;\nvar queue = [];\n/**\n * Check if tokens are currently being refreshed\n *\n * @returns {boolean} True if the tokens are currently being refreshed, false is not\n */\nfunction getIsRefreshing() {\n    return isRefreshing;\n}\nexports.getIsRefreshing = getIsRefreshing;\n/**\n * Update refresh state\n *\n * @param {boolean} newRefreshingState\n */\nfunction setIsRefreshing(newRefreshingState) {\n    isRefreshing = newRefreshingState;\n}\nexports.setIsRefreshing = setIsRefreshing;\n/**\n * Function that resolves all items in the queue with the provided token\n * @param token New access token\n */\nvar resolveQueue = function (token) {\n    queue.forEach(function (p) {\n        p.resolve(token);\n    });\n    queue = [];\n};\n/**\n * Function that declines all items in the queue with the provided error\n * @param error Error\n */\nvar declineQueue = function (error) {\n    queue.forEach(function (p) {\n        p.reject(error);\n    });\n    queue = [];\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}