{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setIsRefreshing = exports.getIsRefreshing = exports.authTokenInterceptor = exports.applyAuthTokenInterceptor = exports.refreshTokenIfNeeded = exports.getAccessToken = exports.getRefreshToken = exports.clearAuthTokens = exports.setAccessToken = exports.setAuthTokens = exports.isLoggedIn = exports.STORAGE_KEY = void 0;\n\nvar jwt_decode_1 = __importDefault(require(\"jwt-decode\"));\n\nvar axios_1 = __importDefault(require(\"axios\"));\n\nvar async_storage_1 = __importDefault(require(\"@react-native-async-storage/async-storage\"));\n\nvar EXPIRE_FUDGE = 10;\nexports.STORAGE_KEY = \"auth-tokens-\" + process.env.NODE_ENV;\n\nvar isLoggedIn = function isLoggedIn() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var token;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, (0, exports.getRefreshToken)()];\n\n        case 1:\n          token = _a.sent();\n          return [2, !!token];\n      }\n    });\n  });\n};\n\nexports.isLoggedIn = isLoggedIn;\n\nvar setAuthTokens = function setAuthTokens(tokens) {\n  return async_storage_1.default.setItem(exports.STORAGE_KEY, JSON.stringify(tokens));\n};\n\nexports.setAuthTokens = setAuthTokens;\n\nvar setAccessToken = function setAccessToken(token) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, getAuthTokens()];\n\n        case 1:\n          tokens = _a.sent();\n\n          if (!tokens) {\n            throw new Error('Unable to update access token since there are not tokens currently stored');\n          }\n\n          tokens.accessToken = token;\n          return [2, (0, exports.setAuthTokens)(tokens)];\n      }\n    });\n  });\n};\n\nexports.setAccessToken = setAccessToken;\n\nvar clearAuthTokens = function clearAuthTokens() {\n  return async_storage_1.default.removeItem(exports.STORAGE_KEY);\n};\n\nexports.clearAuthTokens = clearAuthTokens;\n\nvar getRefreshToken = function getRefreshToken() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, getAuthTokens()];\n\n        case 1:\n          tokens = _a.sent();\n          return [2, tokens ? tokens.refreshToken : undefined];\n      }\n    });\n  });\n};\n\nexports.getRefreshToken = getRefreshToken;\n\nvar getAccessToken = function getAccessToken() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var tokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, getAuthTokens()];\n\n        case 1:\n          tokens = _a.sent();\n          return [2, tokens ? tokens.accessToken : undefined];\n      }\n    });\n  });\n};\n\nexports.getAccessToken = getAccessToken;\n\nvar refreshTokenIfNeeded = function refreshTokenIfNeeded(requestRefresh) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var accessToken;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, (0, exports.getAccessToken)()];\n\n        case 1:\n          accessToken = _a.sent();\n          if (!(!accessToken || isTokenExpired(accessToken))) return [3, 3];\n          return [4, refreshToken(requestRefresh)];\n\n        case 2:\n          accessToken = _a.sent();\n          _a.label = 3;\n\n        case 3:\n          return [2, accessToken];\n      }\n    });\n  });\n};\n\nexports.refreshTokenIfNeeded = refreshTokenIfNeeded;\n\nvar applyAuthTokenInterceptor = function applyAuthTokenInterceptor(axios, config) {\n  if (!axios.interceptors) throw new Error(\"invalid axios instance: \" + axios);\n  axios.interceptors.request.use((0, exports.authTokenInterceptor)(config));\n};\n\nexports.applyAuthTokenInterceptor = applyAuthTokenInterceptor;\n\nvar getAuthTokens = function getAuthTokens() {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var rawTokens;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4, async_storage_1.default.getItem(exports.STORAGE_KEY)];\n\n        case 1:\n          rawTokens = _a.sent();\n          if (!rawTokens) return [2];\n\n          try {\n            return [2, JSON.parse(rawTokens)];\n          } catch (error) {\n            throw new Error(\"Failed to parse auth tokens: \" + rawTokens);\n          }\n\n          return [2];\n      }\n    });\n  });\n};\n\nvar isTokenExpired = function isTokenExpired(token) {\n  if (!token) return true;\n  var expiresIn = getExpiresIn(token);\n  return !expiresIn || expiresIn <= EXPIRE_FUDGE;\n};\n\nvar getTimestampFromToken = function getTimestampFromToken(token) {\n  var decoded = (0, jwt_decode_1.default)(token);\n  return decoded.exp;\n};\n\nvar getExpiresIn = function getExpiresIn(token) {\n  var expiration = getTimestampFromToken(token);\n  if (!expiration) return -1;\n  return expiration - Date.now() / 1000;\n};\n\nvar refreshToken = function refreshToken(requestRefresh) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var refreshToken, newTokens, error_1, status_1;\n\n    var _a;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4, (0, exports.getRefreshToken)()];\n\n        case 1:\n          refreshToken = _b.sent();\n          if (!refreshToken) throw new Error('No refresh token available');\n          _b.label = 2;\n\n        case 2:\n          _b.trys.push([2, 8,, 11]);\n\n          return [4, requestRefresh(refreshToken)];\n\n        case 3:\n          newTokens = _b.sent();\n          if (!(typeof newTokens === 'object' && (newTokens === null || newTokens === void 0 ? void 0 : newTokens.accessToken))) return [3, 5];\n          return [4, (0, exports.setAuthTokens)(newTokens)];\n\n        case 4:\n          _b.sent();\n\n          return [2, newTokens.accessToken];\n\n        case 5:\n          if (!(typeof newTokens === 'string')) return [3, 7];\n          return [4, (0, exports.setAccessToken)(newTokens)];\n\n        case 6:\n          _b.sent();\n\n          return [2, newTokens];\n\n        case 7:\n          return [3, 11];\n\n        case 8:\n          error_1 = _b.sent();\n          if (!axios_1.default.isAxiosError(error_1)) throw error_1;\n          status_1 = (_a = error_1.response) === null || _a === void 0 ? void 0 : _a.status;\n          if (!(status_1 === 401 || status_1 === 422)) return [3, 10];\n          return [4, async_storage_1.default.removeItem(exports.STORAGE_KEY)];\n\n        case 9:\n          _b.sent();\n\n          error_1.message = \"Got \" + status_1 + \" on token refresh; clearing both auth tokens\";\n          _b.label = 10;\n\n        case 10:\n          throw error_1;\n\n        case 11:\n          throw new Error('requestRefresh must either return a string or an object with an accessToken');\n      }\n    });\n  });\n};\n\nvar authTokenInterceptor = function authTokenInterceptor(_a) {\n  var _b = _a.header,\n      header = _b === void 0 ? 'Authorization' : _b,\n      _c = _a.headerPrefix,\n      headerPrefix = _c === void 0 ? 'Bearer ' : _c,\n      requestRefresh = _a.requestRefresh;\n  return function (requestConfig) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var refreshToken, authenticateRequest, accessToken, error_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4, (0, exports.getRefreshToken)()];\n\n          case 1:\n            refreshToken = _a.sent();\n            if (!refreshToken) return [2, requestConfig];\n\n            authenticateRequest = function authenticateRequest(token) {\n              if (token) requestConfig.headers[header] = \"\" + headerPrefix + token;\n              return requestConfig;\n            };\n\n            if (isRefreshing) {\n              return [2, new Promise(function (resolve, reject) {\n                queue.push({\n                  resolve: resolve,\n                  reject: reject\n                });\n              }).then(authenticateRequest)];\n            }\n\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4, 5, 6]);\n\n            isRefreshing = true;\n            return [4, (0, exports.refreshTokenIfNeeded)(requestRefresh)];\n\n          case 3:\n            accessToken = _a.sent();\n            return [3, 6];\n\n          case 4:\n            error_2 = _a.sent();\n            declineQueue(error_2);\n\n            if (error_2 instanceof Error) {\n              error_2.message = \"Unable to refresh access token for request due to token refresh error: \" + error_2.message;\n            }\n\n            throw error_2;\n\n          case 5:\n            isRefreshing = false;\n            return [7];\n\n          case 6:\n            resolveQueue(accessToken);\n            return [2, authenticateRequest(accessToken)];\n        }\n      });\n    });\n  };\n};\n\nexports.authTokenInterceptor = authTokenInterceptor;\nvar isRefreshing = false;\nvar queue = [];\n\nfunction getIsRefreshing() {\n  return isRefreshing;\n}\n\nexports.getIsRefreshing = getIsRefreshing;\n\nfunction setIsRefreshing(newRefreshingState) {\n  isRefreshing = newRefreshingState;\n}\n\nexports.setIsRefreshing = setIsRefreshing;\n\nvar resolveQueue = function resolveQueue(token) {\n  queue.forEach(function (p) {\n    p.resolve(token);\n  });\n  queue = [];\n};\n\nvar declineQueue = function declineQueue(error) {\n  queue.forEach(function (p) {\n    p.reject(error);\n  });\n  queue = [];\n};","map":{"version":3,"mappings":"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","names":["EXPIRE_FUDGE","exports","process","env","NODE_ENV","isLoggedIn","token","_a","setAuthTokens","tokens","setItem","JSON","stringify","setAccessToken","getAuthTokens","Error","accessToken","clearAuthTokens","removeItem","getRefreshToken","refreshToken","undefined","getAccessToken","refreshTokenIfNeeded","requestRefresh","isTokenExpired","applyAuthTokenInterceptor","axios","config","interceptors","request","use","async_storage_1","getItem","rawTokens","parse","error","expiresIn","getExpiresIn","getTimestampFromToken","decoded","exp","expiration","Date","now","_b","newTokens","axios_1","isAxiosError","error_1","status_1","response","status","message","authTokenInterceptor","header","_c","headerPrefix","requestConfig","authenticateRequest","headers","isRefreshing","Promise","resolve","reject","queue","push","then","declineQueue","error_2","resolveQueue","getIsRefreshing","setIsRefreshing","newRefreshingState","forEach","p"],"sourceRoot":"","sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}