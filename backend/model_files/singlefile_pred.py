# -*- coding: utf-8 -*-
"""singlefile_pred.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GXNdiaqdX-G-EhwwyG5VFTZP3jhh5mk5
"""

import numpy as np
import os
import csv
import pickle
from pickle import load

DATA_DIR_B = 'C:/Users/Fatima/Documents/GitHub/eeg-app/backend/model_files/'
data1 = []

with open(DATA_DIR_B + 'ahsaan.csv') as file_obj:
    reader_obj = csv.reader(file_obj)
    temp = []
    row_count=0
    for row in reader_obj:
      if(row_count>=100):
        break
      for index in range(len(row)):
        
        row[index] = float(row[index])
        row[index] = (row[index] * (1.8/4096) ) / 2000
        # print(row[index])
        temp.append(row[index])
      row_count+=1
    data1.append([temp])

# print(data1)

data1 = np.array([d[0] for d in data1])
# data1.shape

X1 = []
Y1 = []
b = 178


for i in range(data1.shape[0]):
  for w in np.arange(0,712,178):
    X1.append([data1[i,w:w+b]])

X1 = np.array([d[0] for d in X1 if 0 not in d[0].shape])

# X1.shape

from scipy.signal import butter,lfilter

fs = 173.61
cutoff = 40 #Hz
nq = 0.5 * fs
ncutoff = cutoff/nq
b,a = butter(5,ncutoff,btype = 'low')

size = X1.shape[0]

X_new  = []
#butter worth coefficients are already created
for i in range(X1.shape[0]):
  X_new.append([lfilter(b,a,X1[i])])

X_new = np.array([X_new])
X = np.reshape(X_new , (size,178))

# from sklearn.decomposition import FastICA
# from sklearn.preprocessing import StandardScaler
from scipy.signal import welch

# X1.shape

ica1 = load(open('C:/Users/Fatima/Documents/GitHub/eeg-app/backend/model_files/ica.pkl', 'rb'))
# ica1 = load(open('G:/My Drive/ica_warn.pkl','rb'))

scaler1 = load(open('C:/Users/Fatima/Documents/GitHub/eeg-app/backend/model_files/sc1.pkl', 'rb'))

X_pred1= ica1.transform(X1)

X_pred1 = scaler1.transform(X_pred1)

# X_pred1.shape

filename = 'C:/Users/Fatima/Documents/GitHub/eeg-app/backend/model_files/one_class_svm.sav'
loaded_model = pickle.load(open(filename, 'rb'))
result = loaded_model.predict(X_pred1)

tl= len(result)
negatives=np.sum(np.array(result) <= 0, axis=0)
pc  = negatives/tl
print(pc)